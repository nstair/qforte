# qforte.pyi - Type stubs for the qforte quantum chemistry library
# Auto-generated from bindings.cc - DO NOT EDIT MANUALLY
from typing import List, Dict, Tuple, Union, Optional, Iterator, Any, overload
import numpy as np
from numpy.typing import NDArray

# Complex number type alias
Complex = Union[complex, float]

class Circuit:
    """Quantum circuit class for building and manipulating quantum circuits."""
    def __init__(self) -> None: ...
    def add(self, gate: Gate) -> None: ...
    def add(self, circuit: Circuit) -> None: ...
    def add_gate(self, gate: Gate) -> None: ...
    def add_circuit(self, circuit: Circuit) -> None: ...
    def gates(self) -> List[Gate]: ...
    def sparse_matrix(self) -> SparseMatrix: ...
    def size(self) -> int: ...
    def adjoint(self) -> Circuit: ...
    def canonicalize_pauli_circuit(self) -> None: ...
    def set_parameters(self, parameters: List[Complex]) -> None: ...
    def get_num_cnots(self) -> int: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class SQOperator:
    """Second quantized operator class."""
    def __init__(self) -> None: ...
    def add(self, coeff: Complex, indices: List[int], ops: List[str]) -> None: ...
    def add(self, other: SQOperator) -> None: ...
    def add_term(self, coeff: Complex, indices: List[int], ops: List[str]) -> None: ...
    def add_op(self, other: SQOperator) -> None: ...
    def set_coeffs(self, coeffs: List[Complex]) -> None: ...
    def mult_coeffs(self, factor: Complex) -> None: ...
    def terms(self) -> List[Tuple[Complex, List[int], List[str]]]: ...
    def get_largest_alfa_beta_indices(self) -> Tuple[int, int]: ...
    def many_body_order(self) -> int: ...
    def ranks_present(self) -> List[int]: ...
    def canonical_order(self) -> None: ...
    def simplify(self) -> None: ...
    def jw_transform(self, qubit_excitation: bool = False) -> QubitOperator: ...
    def split_by_rank(self) -> Dict[int, SQOperator]: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class TensorOperator:
    """Tensor operator class for multi-body operators."""
    def __init__(self, max_nbody: int, dim: int, is_spatial: bool = False, is_restricted: bool = False) -> None: ...
    def add_sqop_of_rank(self, rank: int, sqop: SQOperator) -> None: ...
    def tensors(self) -> Dict[int, Tensor]: ...
    def fill_tensor_from_np_by_rank(self, rank: int, array: NDArray[np.complex128]) -> None: ...
    def str(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...
    def __str__(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...
    def __repr__(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...

class SQOpPool:
    """Pool of second quantized operators."""
    def __init__(self) -> None: ...
    def add(self, op: SQOperator) -> None: ...
    def add_hermitian_pairs(self, op: SQOperator) -> None: ...
    def add_term(self, op: SQOperator) -> None: ...
    def set_coeffs(self, coeffs: List[Complex]) -> None: ...
    def set_coeffs_to_scaler(self, coeff: Complex) -> None: ...
    def terms(self) -> List[SQOperator]: ...
    def set_orb_spaces(self, spaces: List[str]) -> None: ...
    def get_qubit_op_pool(self) -> QubitOpPool: ...
    def get_qubit_operator(self, order_type: str, combine_like_terms: bool = True, qubit_excitations: bool = False) -> QubitOperator: ...
    def fill_pool(self, pool_type: str) -> None: ...
    def str(self) -> str: ...
    def __getitem__(self, i: int) -> SQOperator: ...
    def __iter__(self) -> Iterator[SQOperator]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[SQOperator]: ...
    def __getitem__(self, i: int) -> SQOperator: ...
    def __len__(self) -> int: ...

class SQOpPoolThrust:
    """Python binding for SQOpPoolThrust."""
    def __init__(self) -> None: ...
    def add(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_hermitian_pairs(self, *args: Any, **kwargs: Any) -> Any: ...
    def add_term(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_coeffs(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_coeffs_to_scaler(self, *args: Any, **kwargs: Any) -> Any: ...
    def terms(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_orb_spaces(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_qubit_op_pool(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_qubit_operator(self, *args: Any, **kwargs: Any) -> Any: ...
    def fill_pool(self, *args: Any, **kwargs: Any) -> Any: ...
    def check_mu_tuple_container_sizes(self, *args: Any, **kwargs: Any) -> Any: ...
    def print_mu_tuple_dims(self, *args: Any, **kwargs: Any) -> Any: ...
    def print_mu_tuple_elements(self, *args: Any, **kwargs: Any) -> Any: ...
    def str(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getitem__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __iter__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __len__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __str__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __repr__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __len__(self) -> int: ...

class QubitOperator:
    """Qubit operator class for Pauli operators."""
    def __init__(self) -> None: ...
    def add(self, coeff: Complex, pauli_ops: List[Tuple[int, str]]) -> None: ...
    def add(self, other: QubitOperator) -> None: ...
    def add_term(self, coeff: Complex, pauli_ops: List[Tuple[int, str]]) -> None: ...
    def add_op(self, other: QubitOperator) -> None: ...
    def set_coeffs(self, coeffs: List[Complex]) -> None: ...
    def mult_coeffs(self, factor: Complex) -> None: ...
    def terms(self) -> List[Tuple[Complex, List[Tuple[int, str]]]]: ...
    def order_terms(self) -> None: ...
    def canonical_order(self) -> None: ...
    def simplify(self) -> None: ...
    def operator_product(self, other: QubitOperator) -> QubitOperator: ...
    def check_op_equivalence(self, other: QubitOperator, rtol: float = 1e-9) -> bool: ...
    def num_qubits(self) -> int: ...
    def sparse_matrix(self, nqubits: int) -> SparseMatrix: ...
    def str(self) -> str: ...
    def __iter__(self) -> Iterator[Tuple[Complex, List[Tuple[int, str]]]]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[Tuple[Complex, List[Tuple[int, str]]]]: ...

class QubitOpPool:
    """Pool of qubit operators."""
    def __init__(self) -> None: ...
    def add(self, op: QubitOperator) -> None: ...
    def add_term(self, op: QubitOperator) -> None: ...
    def set_coeffs(self, coeffs: List[Complex]) -> None: ...
    def set_op_coeffs(self, op_idx: int, coeffs: List[Complex]) -> None: ...
    def set_terms(self, terms: List[QubitOperator]) -> None: ...
    def terms(self) -> List[QubitOperator]: ...
    def join_op_from_right_lazy(self, other: QubitOperator) -> None: ...
    def join_op_from_right(self, other: QubitOperator) -> None: ...
    def join_op_from_left(self, other: QubitOperator) -> None: ...
    def join_as_commutator(self, other: QubitOperator) -> None: ...
    def square(self) -> None: ...
    def fill_pool(self, pool_type: str) -> None: ...
    def str(self) -> str: ...
    def __iter__(self) -> Iterator[QubitOperator]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[QubitOperator]: ...

class QubitBasis:
    """Computational basis state representation."""
    def __init__(self, n: int = 0) -> None: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def flip_bit(self, qubit: int) -> None: ...
    def set_bit(self, qubit: int) -> None: ...
    def add(self, other: QubitBasis) -> QubitBasis: ...
    def get_bit(self, qubit: int) -> int: ...

class Computer:
    """Quantum computer simulator."""
    def __init__(self, nqubits: int, print_threshold: float = 1.0e-6) -> None: ...
    def apply_circuit_safe(self, circuit: Circuit) -> None: ...
    def apply_matrix(self, matrix: NDArray[np.complex128], qubits: List[int]) -> None: ...
    def apply_sparse_matrix(self, matrix: SparseMatrix, qubits: List[int]) -> None: ...
    def apply_operator(self, op: QubitOperator) -> None: ...
    def apply_circuit(self, circuit: Circuit) -> None: ...
    def apply_gate_safe(self, gate: Gate) -> None: ...
    def apply_gate(self, gate: Gate) -> None: ...
    def apply_constant(self, coeff: Complex) -> None: ...
    def measure_circuit(self, circuit: Circuit, shots: int) -> Dict[str, int]: ...
    def measure_z_readouts_fast(self, shots: int) -> List[str]: ...
    def measure_readouts(self, qubits: List[int], shots: int) -> List[int]: ...
    def perfect_measure_circuit(self, circuit: Circuit) -> Dict[str, Complex]: ...
    def direct_oppl_exp_val(self, op_pool: QubitOpPool) -> List[Complex]: ...
    def direct_idxd_oppl_exp_val(self, op_pool: QubitOpPool, indices: List[int]) -> List[Complex]: ...
    def direct_oppl_exp_val_w_mults(self, op_pool: QubitOpPool, mults: List[Complex]) -> Complex: ...
    def direct_op_exp_val(self, op: QubitOperator) -> Complex: ...
    def direct_circ_exp_val(self, circuit: Circuit) -> Complex: ...
    def direct_pauli_circ_exp_val(self, circuit: Circuit) -> Complex: ...
    def direct_gate_exp_val(self, gate: Gate) -> Complex: ...
    def apply_sq_operator(self, sqop: SQOperator) -> None: ...
    def z_chain(self, qubits: List[int]) -> Complex: ...
    def apply_2x2(self, matrix: NDArray[np.complex128], qubit: int) -> None: ...
    def coeff(self, basis: QubitBasis) -> Complex: ...
    def get_coeff_vec(self) -> List[Complex]: ...
    def get_nqubit(self) -> int: ...
    def set_coeff_vec(self, coeffs: List[Complex]) -> None: ...
    def set_state(self, state: List[Complex]) -> None: ...
    def zero_state(self) -> None: ...
    def get_timings(self) -> Dict[str, float]: ...
    def clear_timings(self) -> None: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class FCIComputerGPU:
    """Full Configuration Interaction computer (GPU version)."""
    def __init__(self, nel: int, sz: int, norb: int) -> None: ...
    def hartree_fock(self) -> None: ...
    def get_hf_dot(self) -> Complex: ...
    def set_element(self, idx: int, value: Complex) -> None: ...
    def to_gpu(self) -> None: ...
    def to_cpu(self) -> None: ...
    def copy_to_tensor(self, tensor: Tensor) -> None: ...
    def get_acc_timer(self) -> local_timer: ...
    def set_state(self, state: Tensor) -> None: ...
    def set_state_gpu(self, state: TensorGPU) -> None: ...
    def set_state_from_tensor(self, state: Tensor) -> None: ...
    def apply_tensor_spin_1bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_012bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_012bdy(self, tensor: Tensor) -> None: ...
    def apply_individual_sqop_term(self, coeff: Complex, indices: List[int], ops: List[str]) -> None: ...
    def apply_sqop(self, sqop: SQOperator) -> None: ...
    def apply_diagonal_of_sqop(self, sqop: SQOperator, invert_coeff: bool = True) -> None: ...
    def apply_sqop_pool(self, pool: SQOpPool) -> None: ...
    def get_exp_val(self, sqop: SQOperator) -> Complex: ...
    def get_exp_val_tensor(self, tensor_op: TensorOperator) -> Complex: ...
    def evolve_op_taylor(self, sqop: SQOperator, time: float, order: int) -> None: ...
    def apply_sqop_evolution(self, time: float, sqop: SQOperator, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def evolve_pool_trotter_basic(self, sqop: SQOperator, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def evolve_pool_trotter(self, sqop: SQOperator, evolution_time: float, trotter_steps: int, trotter_order: int, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def get_state(self) -> Tensor: ...
    def get_state_deep(self) -> Tensor: ...
    def str(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __str__(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __repr__(self, print_data: bool = True, print_complex: bool = False) -> str: ...

class FCIComputer:
    """Full Configuration Interaction computer (CPU version)."""
    def __init__(self, nel: int, sz: int, norb: int) -> None: ...
    def hartree_fock(self) -> None: ...
    def set_element(self, idx: int, value: Complex) -> None: ...
    def do_on_gpu(self) -> None: ...
    def do_on_cpu(self) -> None: ...
    def get_acc_timer(self) -> local_timer: ...
    def apply_tensor_spin_1bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_012bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_012bdy(self, tensor: Tensor) -> None: ...
    def apply_individual_sqop_term(self, coeff: Complex, indices: List[int], ops: List[str]) -> None: ...
    def apply_sqop(self, sqop: SQOperator) -> None: ...
    def apply_diagonal_of_sqop(self, sqop: SQOperator, invert_coeff: bool = True) -> None: ...
    def apply_sqop_pool(self, pool: SQOpPool) -> None: ...
    def get_exp_val(self, sqop: SQOperator) -> Complex: ...
    def get_exp_val_tensor(self, tensor_op: TensorOperator) -> Complex: ...
    def evolve_op_taylor(self, sqop: SQOperator, time: float, order: int) -> None: ...
    def apply_sqop_evolution(self, time: float, sqop: SQOperator, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def evolve_pool_trotter_basic(self, sqop: SQOperator, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def evolve_pool_trotter(self, sqop: SQOperator, evolution_time: float, trotter_steps: int, trotter_order: int, antiherm: bool = False, adjoint: bool = False) -> None: ...
    def set_state(self, state: Tensor) -> None: ...
    def get_state(self) -> Tensor: ...
    def get_state_deep(self) -> Tensor: ...
    def get_hf_dot(self) -> Complex: ...
    def str(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __str__(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __repr__(self, print_data: bool = True, print_complex: bool = False) -> str: ...

class FCIGraph:
    """FCI graph for determinant indexing."""
    def __init__(self, nalfa: int, nbeta: int, norb: int) -> None: ...
    def make_mapping_each(self) -> None: ...
    def get_nalfa(self) -> int: ...
    def get_nbeta(self) -> int: ...
    def get_lena(self) -> int: ...
    def get_lenb(self) -> int: ...
    def get_astr(self) -> List[int]: ...
    def get_bstr(self) -> List[int]: ...
    def get_aind(self) -> List[int]: ...
    def get_bind(self) -> List[int]: ...
    def get_alfa_map(self) -> Dict[int, int]: ...
    def get_beta_map(self) -> Dict[int, int]: ...
    def get_dexca(self) -> Dict[Tuple[int, int], List[Tuple[int, float]]]: ...
    def get_dexcb(self) -> Dict[Tuple[int, int], List[Tuple[int, float]]]: ...
    def get_dexca_vec(self) -> List[List[Tuple[int, float]]]: ...
    def get_dexcb_vec(self) -> List[List[Tuple[int, float]]]: ...

class Tensor:
    """Multi-dimensional tensor class."""
    def __init__(self) -> None: ...
    def __init__(self, shape: List[int], name: str) -> None: ...
    def name(self) -> str: ...
    def ndim(self) -> int: ...
    def size(self) -> int: ...
    def shape(self) -> List[int]: ...
    def strides(self) -> List[int]: ...
    def set(self, indices: List[int], value: Complex) -> None: ...
    def copy_in(self, other: Tensor) -> None: ...
    def add_to_element(self, indices: List[int], value: Complex) -> None: ...
    def get(self, indices: List[int]) -> Complex: ...
    def fill_from_np(self, array: NDArray[np.complex128]) -> None: ...
    def add(self, other: Tensor) -> None: ...
    def subtract(self, other: Tensor) -> None: ...
    def norm(self) -> float: ...
    def scale(self, factor: Complex) -> None: ...
    def vector_dot(self, other: Tensor) -> Complex: ...
    def identity(self) -> None: ...
    def zero(self) -> None: ...
    def zero_with_shape(self, shape: List[int]) -> None: ...
    def symmetrize(self, indices: List[int]) -> None: ...
    def antisymmetrize(self, indices: List[int]) -> None: ...
    def transpose(self, axes: List[int]) -> Tensor: ...
    def general_transpose(self, axes: List[int]) -> Tensor: ...
    def fill_from_nparray(self, array: NDArray[np.complex128], shape: List[int]) -> None: ...
    def copy_in_tensorgpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def zaxpy(self, x: Tensor, alpha: Complex, incx: int = 1, incy: int = 1) -> None: ...
    def zaxpby(self, x: Tensor, a: Complex, b: Complex, incx: int = 1, incy: int = 1) -> None: ...
    def gemm(self, B: Tensor, transa: str = "N", transb: str = "N", alpha: Complex = 1.0, beta: Complex = 1.0, mult_B_on_right: bool = False) -> None: ...
    def slice(self, start: List[int], end: List[int]) -> Tensor: ...
    def get_nonzero_tidxs(self) -> List[List[int]]: ...
    def str(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...
    def __str__(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...
    def __repr__(self, print_data: bool = True, print_complex: bool = False, maxcols: int = 5, data_format: str = "%12.7f", header_format: str = "%12zu") -> str: ...
    @staticmethod
    def chain(As: List[Tensor], trans: List[str], alpha: Complex = 1.0, beta: Complex = 0.0) -> Tensor: ...
    @staticmethod
    def einsum(Ainds: List[str], Binds: List[str], Cinds: List[str], A: Tensor, B: Tensor, C3: Tensor, alpha: Complex = 1.0, beta: Complex = 0.0) -> None: ...
    @staticmethod
    def permute(Ainds: List[str], Cinds: List[str], A: Tensor, C2: Tensor, alpha: Complex = 1.0, beta: Complex = 0.0) -> None: ...

class TensorGPU:
    """GPU tensor class."""
    def __init__(self) -> None: ...
    def __init__(self, shape: List[int], name: str, on_gpu: bool) -> None: ...
    def to_gpu(self) -> None: ...
    def to_cpu(self) -> None: ...
    def add(self, other: TensorGPU) -> None: ...
    def add2(self, other: TensorGPU) -> None: ...
    def addThrust(self, other: TensorGPU) -> None: ...
    def zero(self) -> None: ...
    def shape(self) -> List[int]: ...
    def norm(self) -> float: ...
    def ndim_error(self, expected: int) -> None: ...
    def fill_from_nparray(self, array: NDArray[np.complex128], shape: List[int]) -> None: ...
    def copy_in(self, other: TensorGPU) -> None: ...
    def copy_in_gpu(self, other: TensorGPU) -> None: ...
    def copy_in_from_tensor(self, other: Tensor) -> None: ...
    def subtract(self, other: TensorGPU) -> None: ...
    def set(self, indices: List[int], value: Complex) -> None: ...
    def get(self, indices: List[int]) -> Complex: ...

class Gate:
    """Quantum gate class."""
    def __init__(self) -> None: ...
    def target(self) -> int: ...
    def control(self) -> int: ...
    def gate_id(self) -> str: ...
    def sparse_matrix(self) -> SparseMatrix: ...
    def adjoint(self) -> Gate: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class SparseVector:
    """Sparse vector class."""
    def __init__(self) -> None: ...
    def get_element(self, idx: int) -> Complex: ...
    def set_element(self, idx: int, value: Complex) -> None: ...
    def to_map(self) -> Dict[int, Complex]: ...

class SparseMatrix:
    """Sparse matrix class."""
    def __init__(self) -> None: ...
    def get_element(self, row: int, col: int) -> Complex: ...
    def set_element(self, row: int, col: int, value: Complex) -> None: ...
    def to_vec_map(self) -> List[Dict[int, Complex]]: ...
    def to_map(self) -> Dict[Tuple[int, int], Complex]: ...

class local_timer:
    """Local timer for benchmarking."""
    def __init__(self) -> None: ...
    def reset(self) -> None: ...
    def get(self) -> float: ...
    def record(self, label: str) -> None: ...
    def get_timings(self) -> Dict[str, float]: ...
    def get_acc_timings(self) -> Dict[str, float]: ...
    def acc_begin(self, *args: Any, **kwargs: Any) -> Any: ...
    def acc_end(self, *args: Any, **kwargs: Any) -> Any: ...
    def str_table(self, *args: Any, **kwargs: Any) -> Any: ...
    def acc_str_table(self, *args: Any, **kwargs: Any) -> Any: ...
    def __str__(self) -> str: ...

class TensorThrust:
    """Thrust GPU tensor class."""
    def __init__(self) -> None: ...
    def __init__(self, shape: List[int], name: str = "T", on_gpu: bool = False) -> None: ...
    def to_gpu(self) -> None: ...
    def to_cpu(self) -> None: ...
    def add(self, other: TensorThrust) -> None: ...
    def zero(self) -> None: ...
    def set(self, idx: int, value: Complex) -> None: ...
    def fill_from_nparray(self, array: NDArray[np.complex128], shape: List[int]) -> None: ...
    def __repr__(self) -> str: ...

class FCIComputerThrust:
    """Full Configuration Interaction computer (Thrust GPU version)."""
    def __init__(self, nel: int, sz: int, norb: int) -> None: ...
    def hartree_fock_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_hf_dot(self) -> Complex: ...
    def set_element(self, idx: int, value: Complex) -> None: ...
    def to_gpu(self) -> None: ...
    def to_cpu(self) -> None: ...
    def copy_to_tensor_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_acc_timer(self) -> local_timer: ...
    def set_state_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_state_gpu(self, state: TensorGPU) -> None: ...
    def set_state_from_tensor_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def apply_tensor_spin_1bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spin_012bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_12bdy(self, tensor: Tensor) -> None: ...
    def apply_tensor_spat_012bdy(self, tensor: Tensor) -> None: ...
    def apply_individual_sqop_term_gpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def apply_sqop_gpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def apply_diagonal_of_sqop_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def apply_sqop_pool_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_exp_val_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_exp_val_tensor_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_op_taylor_cpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def apply_sqop_evolution_gpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_basic_gpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_gpu(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_gpu_v2(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_gpu_v3(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_gpu_v4(self, *args: Any, **kwargs: Any) -> Any: ...
    def evolve_pool_trotter_gpu_v5(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_state(self) -> Tensor: ...
    def get_state_deep(self) -> Tensor: ...
    def populate_index_arrays_for_pool_evo(self, *args: Any, **kwargs: Any) -> Any: ...
    def copy_to_tensor_thrust_gpu(self, tensor: TensorThrust) -> None: ...
    def copy_to_tensor_thrust_cpu(self, tensor: TensorThrust) -> None: ...
    def get_shape(self) -> List[int]: ...
    def str(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __str__(self, print_data: bool = True, print_complex: bool = False) -> str: ...
    def __repr__(self, print_data: bool = True, print_complex: bool = False) -> str: ...

class FCIGraphThrust:
    """Python binding for FCIGraphThrust."""
    def __init__(self) -> None: ...
    def make_mapping_each(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_nalfa(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_nbeta(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_lena(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_lenb(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_astr(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_bstr(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_aind(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_bind(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_alfa_map(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_beta_map(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_dexca(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_dexcb(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_dexca_vec(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_dexcb_vec(self, *args: Any, **kwargs: Any) -> Any: ...

# Standalone functions
@overload
def gate(type: str, target: int, parameter: Complex = 0.0) -> Gate: ...

@overload
def gate(type: str, target: int, control: int) -> Gate: ...

@overload
def gate(type: str, target: int, control: int, parameter: Complex = 0.0) -> Gate: ...

@overload
def gate(type: str, target: int, parameter: Complex = 0.0) -> Gate: ...

@overload
def gate(type: str, target: int, control: int) -> Gate: ...

@overload
def gate(type: str, target: int, control: int, parameter: Complex = 0.0) -> Gate: ...

@overload
def gate(type: str, target: int, parameter: Complex = 0.0) -> Gate: ...

@overload
def gate(type: str, target: int, control: int) -> Gate: ...

@overload
def gate(type: str, target: int, control: int, parameter: Complex = 0.0) -> Gate: ...

def control_gate(control: int, gate: Gate) -> Gate: ...


# Additional functions that may be imported from submodules
def system_factory(
    build_type: str,
    mol_geometry: List[Tuple[str, Tuple[float, float, float]]],
    basis: str,
    build_qb_ham: bool = True,
    run_fci: int = 0,
    **kwargs: Any
) -> Any: ...
